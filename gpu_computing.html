<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Learn Computer Science</title>

    <script defer src="/index.js"></script>
    <script defer src="/lib/highlight/highlight.min.js"></script>

    <link rel="stylesheet" type="text/css" href="/index.css">
    <link rel="stylesheet" type="text/css" href="/lib/highlight/styles/default.min.css">
  </head>
  <body onload="after_load()">
    <div class="segment-markdown"><h1> GPU computing</h1>

<p>Programming on GPU is very different from the standard way of
designing algorithms that run on CPU. Not everything can be easily
expressed in a parallelizable manner.</p>

<p>Suppose you are trying to simulate a 3D space with some particles in it.
Every particle has some position and velocity</p>


<pre><code class="language-c">struct Particle{
    vec3 position; // vector of 3 floating-point numbers
    vec3 velocity; // has direction and magnitude (speed)
}
</code></pre>


<p>The simulation will progress in discrete time-steps.
At each step we iterate over all the particles and update
their position.</p>


<pre><code class="language-c">Particle[] particles;

for(int step=0;step&lt;NUMBER_OF_STEPS_TO_SIMULATE;step++){ 
   for(int i=0;i&lt;NUMBE_OF_PARTICLES;i++){
       particles[i].position += particles[i].velocity; 
   }
}
</code></pre>


<p>If there are 10 particles and updating a single one of them takes
one millisecond, then one step of simulation will take 10 milliseconds.
If there are 1000 particles then a single step will take an entire second!
Notice that all of those particles are updated in the exact same way,
and the position of one particle does not depend on another.
We might as well distribute the simulation among a thousand computers,
each one of them simulating only one specific particle. This way
a single time step with a 1000 particles would take only one millisecond!</p>

<p>Therefore, let's rewrite this code to run on multiple computers at once.</p>


<pre><code class="language-c">Particle[] particles;
int i; // index of the specific particle that this computer simulates
for(int step=0;step&lt;NUMBER_OF_STEPS_TO_SIMULATE;step++){ 
   particles[i].position += particles[i].velocity; 
}
</code></pre>


<p>All we need to do now is to assign some unique number <code class="inlined-code">i</code> to every computer
and then execute this algorithm on all machines in parallel. This is the
essence of GPU computing. You always need to find some way to express your
algorithm in the form of a loop</p>


<pre><code class="language-c">for(int i=0;i&lt;XXX;i++){
   f(i);
}
</code></pre>


<p>If you can do that, then you might as well tell the GPU to execute <code class="inlined-code">f</code> 
in parallel, and you will no longer need the loop.</p>

<p>It might happen that your code is too complex to be reduced to the form
above. This is especially true when you need to access the results computed
by other threads. In such cases you might try dividing the computation
into several stages. Between those stages the threads will have some
time to share the data with each other. 
Going  back to the example with multiple computers, you might think of it as follows.
First the computers calculates something in parallel. When they finish, they briefly
stop the simulation and take a moment to send their results over the network
so that other computers could receive it. Once all computers got what they need, 
they resume the computation.
So essentially you try to reduce your algorithm to</p>


<pre><code class="language-c">int[] global_memory_visible_to_all_threads;

for(int i=0;i&lt;XXX;i++){
   first_stage(i); // writes to global memory
}
for(int i=0;i&lt;YYY;i++){
   second_stage(i); // reads from global memory
}
</code></pre></div>
  </body>
</html>
