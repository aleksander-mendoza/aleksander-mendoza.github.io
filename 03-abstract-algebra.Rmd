# Abstract Algebra

This chapter follows the book [Basic algebra by Nathan Jacobson](http://www.math.toronto.edu/~ila/Jacobson-Basic_algebra_I%20(1).pdf). It builds upon and extends the
formalism in
[Exploring the Structure of an Algebra Text with Locales by Clemens Ballarin](https://link.springer.com/epdf/10.1007/s10817-019-09537-9?sharing_token=97W4MSZFK4L3uH0elVRVH_e4RwlQNchNByi7wbcMAY5KYc96dcTyHMdpryx1k5gi0WC5UEo8zvJiqdCXY5-2wcE2iSbm4nby37i1CuC23KYX2dRyQ6bb6iCFQNnf5ySYrPcgW6Z1geuTK0yg39y9_0Emi-dA9oIjpw_onj6gMkg%3D). You can import it from AFP (see \@ref(afp))

```
theory XXX
  imports Main "Jacobson_Basic_Algebra.Group_Theory"
begin

end       
```


## Monoids


Monoid is a set `M` equipped with a `composition` (also called "multiplication") operation `â‹…`
and a `unit` (also called "neutral") element `ğŸ­`. 

```
text â€¹Def 1.1â€º  (* this is definition 1.1 from the Basic algebra book*)
text â€¹p 28, ll 28--30â€º (* you can find it on page 28 *)
locale monoid =
  fixes M and composition (infixl "â‹…" 70) and unit ("ğŸ­")
  assumes composition_closed [intro, simp]: "âŸ¦ a âˆˆ M; b âˆˆ M âŸ§ âŸ¹ a â‹… b âˆˆ M"
    and unit_closed [intro, simp]: "ğŸ­ âˆˆ M"
    and associative [intro]: "âŸ¦ a âˆˆ M; b âˆˆ M; c âˆˆ M âŸ§ âŸ¹ (a â‹… b) â‹… c = a â‹… (b â‹… c)"
    and left_unit [intro, simp]: "a âˆˆ M âŸ¹ ğŸ­ â‹… a = a"
    and right_unit [intro, simp]: "a âˆˆ M âŸ¹ a â‹… ğŸ­ = a"
```
Because this definition of `monoid` fixes three constants `M`, `composition` and `uni`,
most math textbooks would say that `monoid` is a triple `(M,â‹…,ğŸ­)`.

Most axioms are similar to those in \@ref(main-monoids) but one is new.
The axiom `composition_closed` says that the operation is closed, meaning that if we only operate on elements from `M`
we will never go outside of this set. This axiom was missing in \@ref(main-monoids) which was severely limiting
because without `M` and `composition_closed` it is impossible to define submonoids.

```
text â€¹p 29, ll 27--28â€º
locale submonoid = monoid M "(â‹…)" ğŸ­
  for N and M and composition (infixl "â‹…" 70) and unit ("ğŸ­") +
  assumes subset: "N âŠ† M"
    and sub_composition_closed: "âŸ¦ a âˆˆ N; b âˆˆ N âŸ§ âŸ¹ a â‹… b âˆˆ N"
    and sub_unit_closed: "ğŸ­ âˆˆ N"
```
The `for` keyword specifies that `monoid` is a prerequisite for `submonoid`. It is equivalent to the following (more familiar \@ref(main-monoids)) syntax definition
```
locale submonoid = monoid + 
  fixes N 
  assumes subset: "N âŠ† M" 
    and sub_composition_closed: "[| a âˆˆ N; b âˆˆ N |] âŸ¹ a Â· b âˆˆ N" 
    and sub_unit_closed: "ğŸ­ âˆˆ N"
```
with the only difference being the order of fixed constants (previously it was `N M composition unit` and now its `M composition unit N`). 
In fact this latter definition (without `for`) is merely a syntactic sugar for the former one (with `for`).

The axiom `sub_composition_closed` states that a submonoid is a subset `N` of monoid `M` such that the operation `Â·` is closed in `N`. 

As an example we can show that  `nat` is a monoid under the addition operation
<details>
  <summary>Proof</summary>
```
theory Test
  imports  "Jacobson_Basic_Algebra.Group_Theory"
begin

hide_type nat
no_notation plus (infixl "+" 65) and Groups.zero_class.zero ("0")

datatype nat = Zero ("0") | Suc nat

primrec plus :: "nat â‡’ nat â‡’ nat" (infixl "+" 65) where
"0 + y = y" |
"(Suc x) + y = Suc (x + y)"

interpretation plus: monoid "UNIV" plus Zero
proof
  fix a b c :: "nat"
  show "a âˆˆ UNIV âŸ¹ b âˆˆ UNIV âŸ¹ a + b âˆˆ UNIV"
    by simp_all
  show "0 âˆˆ UNIV"
    by simp
  show "a âˆˆ UNIV âŸ¹ b âˆˆ UNIV âŸ¹ c âˆˆ UNIV âŸ¹ a + b + c = a + (b + c)"
    by (simp, induct_tac a, auto) 
  show "a âˆˆ UNIV âŸ¹ 0 + a = a"
    by simp
  show "a âˆˆ UNIV âŸ¹ a + 0 = a"
    by (simp, induct_tac a, auto) 
qed
end
```
</details>
and that even numbers form a submonoid.
<details>
  <summary>Proof</summary>
Adding two even numbers together must yield  another even number, hence 
the monoid is closed in the set of even numbers.

```
theory Test
  imports  "Jacobson_Basic_Algebra.Group_Theory"
begin

hide_type nat
no_notation plus (infixl "+" 65) and Groups.zero_class.zero ("0")

datatype nat = Zero ("0") | Suc nat

primrec plus :: "nat â‡’ nat â‡’ nat" (infixl "+" 65) where
l_zero: "0 + y = y" | (* we assign the name l_zero to this equation so that we can use it like a theorem *)
suc_dist: "(Suc x) + y = Suc (x + y)"

inductive_set even :: "nat set" where
zero_is_even[intro!]: "0 âˆˆ even" |
step[intro!]: "n âˆˆ even âŸ¹ (Suc (Suc n)) âˆˆ even"
(* Note: you can check the two following types in the Query tab *)
(* Test.even :: "nat set" *)
(* Group_Theory.monoid :: "'a set â‡’ ('a â‡’ 'a â‡’ 'a) â‡’ 'a â‡’ bool" *)
interpretation plus: monoid "even" plus Zero
proof
  fix a b c :: "nat"
  show "a âˆˆ even âŸ¹ b âˆˆ even âŸ¹ a + b âˆˆ even"
    apply(erule even.induct)
(* we perform induction as defined by the inductive_set
 1. b âˆˆ even âŸ¹ 0 + b âˆˆ even
 2. â‹€n. b âˆˆ even âŸ¹ n âˆˆ even âŸ¹ n + b âˆˆ even âŸ¹ Suc (Suc n) + b âˆˆ even 
*)
     apply(simp) (* this solves the 1. goal *)
    apply(subst suc_dist) (* â‹€n. b âˆˆ even âŸ¹ n âˆˆ even âŸ¹ n + b âˆˆ even âŸ¹ Suc (Suc n + b) âˆˆ even *)
    apply(subst suc_dist) (* â‹€n. b âˆˆ even âŸ¹ n âˆˆ even âŸ¹ n + b âˆˆ even âŸ¹ Suc (Suc (n + b)) âˆˆ even *)
    apply(rule step) (* â‹€n. b âˆˆ even âŸ¹ n âˆˆ even âŸ¹ n + b âˆˆ even âŸ¹ n + b âˆˆ even *)
    apply(assumption) (* the  "n + b âˆˆ even" is already among premises *)
    done
  show "0 âˆˆ even"
    by(rule zero_is_even)
  show "a âˆˆ even âŸ¹ b âˆˆ even âŸ¹ c âˆˆ even âŸ¹ a + b + c = a + (b + c)"
    by(erule even.induct, auto)
  show "a âˆˆ even âŸ¹ 0 + a = a"
    by simp
  show "a âˆˆ even âŸ¹ a + 0 = a"
    by (erule even.induct, auto) 
qed
end
```
</details>

Every submonoid is also a monoid, which is expressed using `sublocale` command.

```
context submonoid begin

text â€¹p 29, ll 27--28â€º
lemma sub [intro, simp]:
  "a âˆˆ N âŸ¹ a âˆˆ M"
  using subset by blast

text â€¹p 29, ll 32--33â€º
sublocale sub: monoid N "(â‹…)" ğŸ­
  by unfold_locales (auto simp: sub_composition_closed sub_unit_closed)
end
```
The brackets around `(â‹…)` are necessary, otherwise you will get syntax error.
Note that in the definition of `submonoid` we included `monoid M "(â‹…)" ğŸ­` as a prerequisite but
now we are proving `monoid N "(â‹…)" ğŸ­`.
Once the proof is done you will see
```
local.monoid_axioms: monoid M (â‹…) ğŸ­
```
in the "Find Theorems" tab but it will only show up if you place your cursor inside the `submonoid` context (this is what `local` stands for).

The `submonoid` predicate (locales are predicates \@ref(main-semigroups)) is transitive, meaning that if `K` is
a submonoid of `N` and `N` is a submonoid of `M` then `K` is a submonoid of `M`.

```
text â€¹p 29, ll 33--34â€º
theorem submonoid_transitive:
  assumes "submonoid K N composition unit"
    and "submonoid N M composition unit"
  shows "submonoid K M composition unit"
proof -
  interpret K: submonoid K N composition unit by fact
  interpret M: submonoid N M composition unit by fact
  show ?thesis by unfold_locales auto
qed
```

To understand what this proof does, click for more explanation below.
<details>
<summary>Proof explanation</summary>
```
theorem submonoid_transitive:
  assumes "submonoid K N composition unit"
    and "submonoid N M composition unit"
  shows "submonoid K M composition unit"
proof -
  interpret K: submonoid K N composition unit by fact (* This works analogically to the `fixes` command *)
  interpret M: submonoid N M composition unit by fact (* which allows us to use K and M in the proof. *)
  show ?thesis (* This is shorthand for: "submonoid K M composition unit" *)
    apply(unfold_locales)
(* Current goals:
  1. K âŠ† M
  2. â‹€a b. a âˆˆ K âŸ¹ b âˆˆ K âŸ¹ composition a b âˆˆ K
  3. unit âˆˆ K
*)
    apply(rule "Set.subset_trans"[of K N M])
(* Use query tab to find the theorem and check the type of subset_trans
  Set.subset_trans: ?A âŠ† ?B âŸ¹ ?B âŠ† ?C âŸ¹ ?A âŠ† ?C
 The [of K N M] says that ?A ?B and ?C should be substituted with K N and M yielding rule
  K âŠ† N âŸ¹ N âŠ† M âŸ¹ K âŠ† M
 Its application transforms the goal "K âŠ† M" into two new goals
  1. K âŠ† N
  2. N âŠ† M
  3. â‹€a b. a âˆˆ K âŸ¹ b âˆˆ K âŸ¹ composition a b âˆˆ K
  4. unit âˆˆ K
*)
    apply(rule submonoid.subset[of K N composition unit])
(* Use query tab to find the theorem and check its type
  Group_Theory.submonoid.subset: submonoid ?N ?M ?composition ?unit âŸ¹ ?N âŠ† ?M
 Application of this rule results in
  1. submonoid K N composition unit
  2. N âŠ† M
  3. â‹€a b. a âˆˆ K âŸ¹ b âˆˆ K âŸ¹ composition a b âˆˆ K
  4. unit âˆˆ K
*)
    apply(fact) (* "submonoid K N composition unit" is among premises *)
    apply(rule submonoid.subset[of N M composition unit])
    apply(fact) (* This solves the second subgoal analogically. We are now left with
  1. â‹€a b. a âˆˆ K âŸ¹ b âˆˆ K âŸ¹ composition a b âˆˆ K
  2. unit âˆˆ K
 *)
    apply(rule local.K.sub.composition_closed)
(* 
  1. â‹€a b. a âˆˆ K âŸ¹ b âˆˆ K âŸ¹ a âˆˆ K
  2. â‹€a b. a âˆˆ K âŸ¹ b âˆˆ K âŸ¹ b âˆˆ K
  3. unit âˆˆ K
*)
    apply(assumption)
    apply(assumption)
(* 
  1. unit âˆˆ K
*)
    apply(rule local.K.sub_unit_closed)
    done
qed
```
</details>

### Transformations

A very important example of monoid is the operation of function composition.
Consider some set `S`

```
text â€¹p 28, l 23â€º
locale transformations =
  fixes S :: "'a set"
(*  assumes non_vacuous: "S â‰  {}" *) (* Jacobson requires this but we don't need it, strange. *)
```
then the set of all functions `S â†’â‡©E S` (\@ref(func-sets)) is a monoid under `compose` operation

```
text â€¹Monoid of all transformationsâ€º
text â€¹p 28, ll 23--24â€º
sublocale transformations âŠ† monoid "S â†’â‡©E S" "compose S" "identity S"
  by unfold_locales (auto simp: PiE_def compose_eq compose_assoc Id_compose compose_Id)
```
and `identity` is is the neutral element
```
abbreviation "identity S â‰¡ (Î»x âˆˆ S. x)"
```

## Inverse elements

An element `u` of monoid `M` is invertible if there exist inverse element `v` such that `u â‹… v = ğŸ­`
and `v â‹… u = ğŸ­`.
```
context monoid begin

text â€¹p 31, ll 3--5â€º
definition invertible where "u âˆˆ M âŸ¹ invertible u âŸ· (âˆƒv âˆˆ M. u â‹… v = ğŸ­ âˆ§ v â‹… u = ğŸ­)"
```
For example the inverse of `1` under addition operation (`plus`) is `-1` because `1 + (-1) = 0` and `0` is the neutral element of addition. The inverse of `1` under multiplication is `1` because `1 * 1 = 1` and `1` is the neutral element of multiplication.

<details>
<summary>Introduction and elimination rules needed for automated proofs</summary>
```
text â€¹p 31, ll 3--5â€º
lemma invertibleI [intro]:
  "âŸ¦ u â‹… v = ğŸ­; v â‹… u = ğŸ­; u âˆˆ M; v âˆˆ M âŸ§ âŸ¹ invertible u"
  unfolding invertible_def by fast

text â€¹p 31, ll 3--5â€º
lemma invertibleE [elim]:
  "âŸ¦ invertible u; â‹€v. âŸ¦ u â‹… v = ğŸ­ âˆ§ v â‹… u = ğŸ­; v âˆˆ M âŸ§ âŸ¹ P; u âˆˆ M âŸ§ âŸ¹ P"
  unfolding invertible_def by fast
```
</details>

The inverse element is unique

```
text â€¹p 31, ll 6--7â€º
theorem inverse_unique:
  "âŸ¦ u â‹… v' = ğŸ­; v â‹… u = ğŸ­; u âˆˆ M;  v âˆˆ M; v' âˆˆ M âŸ§ âŸ¹ v = v'"
  by (metis associative left_unit right_unit)
```

because if `u â‹… v' = ğŸ­` and `v â‹… u = ğŸ­` then

```
v â‹… (u â‹… v') = v â‹… ğŸ­
(v â‹… u) â‹… v' = v â‹… ğŸ­
ğŸ­ â‹… v' = v â‹… ğŸ­
v' = v â‹… ğŸ­
v' = v
v = v'
````

<details> <summary> More detailed proof </summary>
Here we are using Isar structured proof syntax. This allows us to use `from`...`have`
to divide the proof into intermediate stepping stones for better readability.
```
theorem inverse_unique:
  assumes uv1:"u â‹… v' = ğŸ­"
  assumes vu1:"v â‹… u = ğŸ­"
  assumes um:"u âˆˆ M"
  assumes vm:"v âˆˆ M"
  assumes v'm:"v' âˆˆ M"
  shows "v = v'"
proof -
  from uv1 have "v â‹… (u â‹… v') = v â‹… ğŸ­"
    apply (rule subst) (* 1. v â‹… (u â‹… v') = v â‹… (u â‹… v') *)
    apply (rule refl) (* No subgoals! *)
    done
  from this um vm v'm have "v â‹… u â‹… v' = v â‹… ğŸ­" (*the keyword 'this' refers to the previous  stepping stone "v â‹… (u â‹… v') = v â‹… ğŸ­" *)
    apply (subst associative)  (* 4 subgoals: *)
(* 
 1. v â‹… (u â‹… v') = v â‹… ğŸ­ âŸ¹ u âˆˆ M âŸ¹ v âˆˆ M âŸ¹ v' âˆˆ M âŸ¹ v âˆˆ M
 2. v â‹… (u â‹… v') = v â‹… ğŸ­ âŸ¹ u âˆˆ M âŸ¹ v âˆˆ M âŸ¹ v' âˆˆ M âŸ¹ u âˆˆ M
 3. v â‹… (u â‹… v') = v â‹… ğŸ­ âŸ¹ u âˆˆ M âŸ¹ v âˆˆ M âŸ¹ v' âˆˆ M âŸ¹ v' âˆˆ M
 4. v â‹… (u â‹… v') = v â‹… ğŸ­ âŸ¹ u âˆˆ M âŸ¹ v âˆˆ M âŸ¹ v' âˆˆ M âŸ¹ v â‹… (u â‹… v') = v â‹… ğŸ­
*)
    apply (assumption) (* each subgoal occurs among the assumptions *)
    apply (assumption)
    apply (assumption)
    apply (assumption)
    done
  from this vu1 have "ğŸ­ â‹… v' = v â‹… ğŸ­"
    apply(subst vu1[symmetric]) (*  1. v â‹… u â‹… v' = v â‹… ğŸ­ âŸ¹ v â‹… u = ğŸ­ âŸ¹ v â‹… u â‹… v' = v â‹… ğŸ­ *)
    apply(assumption) (* No subgoals! *)
    done
  from v'm this have "v' = v â‹… ğŸ­"
    apply(subst left_unit[symmetric]) (* two subgoals: *)
(* 
 1. v' âˆˆ M âŸ¹ ğŸ­ â‹… v' = v â‹… ğŸ­ âŸ¹ v' âˆˆ M
 2. v' âˆˆ M âŸ¹ ğŸ­ â‹… v' = v â‹… ğŸ­ âŸ¹ ğŸ­ â‹… v' = v â‹… ğŸ­
*)
    apply(assumption) (* each subgoal occurs among the assumptions *)
    apply(assumption)
    done
  from vm this show "v = v'"
    apply(subst right_unit[symmetric]) (* 2 subgoals: *)
(*
 1. v âˆˆ M âŸ¹ v' = v â‹… ğŸ­ âŸ¹ v âˆˆ M
 2. v âˆˆ M âŸ¹ v' = v â‹… ğŸ­ âŸ¹ v â‹… ğŸ­ = v' 
*)
    apply(assumption) (*  1. v âˆˆ M âŸ¹ v' = v â‹… ğŸ­ âŸ¹ v â‹… ğŸ­ = v' *)
    apply(rule sym)   (*  1. v âˆˆ M âŸ¹ v' = v â‹… ğŸ­ âŸ¹ v' = v â‹… ğŸ­ *)
    apply(assumption) (* No subgoals! *)
    done
qed
```
</details>

Now that we know the inverse is unique, we can use `THE` to define an inverse function

```
text â€¹p 31, l 7â€º
definition inverse where "inverse = (Î»u âˆˆ M. THE v. v âˆˆ M âˆ§ u â‹… v = ğŸ­ âˆ§ v â‹… u = ğŸ­)"
```

The keyword `THE` is a sister of Hilbert's epsilon operator `SOME` (\@ref(inj-sur-bij))
Notice that this definition requires both `u â‹… v = ğŸ­` and `v â‹… u = ğŸ­`.
If only `u â‹… v = ğŸ­` holds then 
`v` is the right inverse of `u`.
If only `v â‹… u =ğŸ­` holds then 
`v` is the left inverse of `u`.
If `v` is both left and right inverse then `v` is THE `inverse` of `u`.

If inverse does not exist then it is `undefined`

```
text â€¹p 31, l 7â€º
lemma inverse_undefined [intro, simp]:
  "u âˆ‰ M âŸ¹ inverse u = undefined"
  by (simp add: inverse_def)
```

If it does exist then it is guaranteed belong to `M`

```
text â€¹p 31, l 7â€º
lemma invertible_inverse_closed [intro, simp]:
  "âŸ¦ invertible u; u âˆˆ M âŸ§ âŸ¹ inverse u âˆˆ M"
  using inverse_equality by auto
```

Clearly the inverse of neutral element is the element itself

```
text â€¹p 31, l 7â€º
lemma inverse_unit [simp]: "inverse ğŸ­ = ğŸ­"
  using inverse_equality by blast
```

The inverse of an inverse returns back the same element

```
text â€¹p 31, l 8â€º
theorem invertible_inverse_inverse [simp]:
  "âŸ¦ invertible u; u âˆˆ M âŸ§ âŸ¹ inverse (inverse u) = u"
  by (simp add: inverse_equality)
```

The inverses are preserved in submonoids

```
text â€¹p 31, l 7â€º
lemma submonoid_invertible [intro, simp]:
  "âŸ¦ sub.invertible u; u âˆˆ N âŸ§ âŸ¹ invertible u"
  using invertibleI by blast

text â€¹p 31, l 7â€º
lemma submonoid_inverse_closed [intro, simp]:
  "âŸ¦ sub.invertible u; u âˆˆ N âŸ§ âŸ¹ inverse u âˆˆ N"
  using inverse_equality by auto
```

## Groups

If all elements are invertible (the inverse always exists) then we call such monoid a *group*

```
text â€¹Def 1.2â€º
text â€¹p 31, ll 9--10â€º
locale group =
  monoid G "(â‹…)" ğŸ­ for G and composition (infixl "â‹…" 70) and unit ("ğŸ­") +
  assumes invertible [simp, intro]: "u âˆˆ G âŸ¹ invertible u"
```

Subgroups are submonoids of groups whose inverse elements belong to that submonoid.

```
text â€¹p 31, ll 11--12â€º
locale subgroup = submonoid G M "(â‹…)" ğŸ­ + sub: group G "(â‹…)" ğŸ­
  for G and M and composition (infixl "â‹…" 70) and unit ("ğŸ­")
begin

text â€¹Reasoning about @{term invertible} and @{term inverse} in subgroups.â€º

text â€¹p 31, ll 11--12â€º
lemma subgroup_inverse_equality [simp]:
  "u âˆˆ G âŸ¹ inverse u = sub.inverse u"
  by (simp add: inverse_equality)

text â€¹p 31, ll 11--12â€º
lemma subgroup_inverse_iff [simp]:
  "âŸ¦ invertible x; x âˆˆ M âŸ§ âŸ¹ inverse x âˆˆ G âŸ· x âˆˆ G"
  using invertible_inverse_inverse sub.invertible_inverse_closed by fastforce

end (* subgroup *)
```
In other words, subgroups are subsets of groups that are groups themselves and contain the
neutral element.

For example `int` integers are group under addition `+` and `0` is the neutral element. Every integer `i` has an inverse element `-i`. An example of subgroup are the even integers `...,-4, -2, 0, 2, 4,...` but the odd integers are not a subgroup because they do not contain a neutral element nor are closed under addition (sum of two odd numbers gives an even number). Natural numbers `nat` are not a group because `-i` is not a `nat` for any `i` except `0`.
Lists `'a list` are a monoid under append `@` operation but not a group. 

Just like for submonoids, being a subgroup is a transitive relation

```
lemma subgroup_transitive [trans]:
  assumes "subgroup K H composition unit"
    and "subgroup H G composition unit"
  shows "subgroup K G composition unit"
proof -
  interpret K: subgroup K H composition unit by fact
  interpret H: subgroup H G composition unit by fact
  show ?thesis by unfold_locales auto
qed
```

To know whether some set `G` is a subgroup of some group `M` it is enough to check whether the neutral element belongs to `G`, the group operation is closed `g â‹… h âˆˆ G` in `G` and all
elements have their inverses in `G`.

```
text â€¹Jacobson states both directions, but the other one is trivial.â€º
text â€¹p 31, ll 12--15â€º
theorem subgroupI:
  fixes G
  assumes subset [THEN subsetD, intro]: "G âŠ† M"
    and [intro]: "ğŸ­ âˆˆ G"
    and [intro]: "â‹€g h. âŸ¦ g âˆˆ G; h âˆˆ G âŸ§ âŸ¹ g â‹… h âˆˆ G"
    and [intro]: "â‹€g. g âˆˆ G âŸ¹ invertible g"
    and [intro]: "â‹€g. g âˆˆ G âŸ¹ inverse g âˆˆ G"
  shows "subgroup G M (â‹…) ğŸ­"
proof -
  interpret sub: monoid G "(â‹…)" ğŸ­ by unfold_locales auto
  show ?thesis
  proof unfold_locales
    fix u assume [intro]: "u âˆˆ G" show "sub.invertible u"
    using invertible_left_inverse invertible_right_inverse by blast
  qed auto
qed
```

The set of all invertible element of some monoid `M`

```
text â€¹p 31, l 16â€º
definition "Units = {u âˆˆ M. invertible u}"
```

forms a subgroup

```
text â€¹p 31, ll 16--21â€º
interpretation units: subgroup Units M
proof (rule subgroupI)
  fix u1 u2
  assume Units [THEN mem_UnitsD, simp]: "u1 âˆˆ Units" "u2 âˆˆ Units"
  have "(u1 â‹… u2) â‹… (inverse u2 â‹… inverse u1) = (u1 â‹… (u2 â‹… inverse u2)) â‹… inverse u1"
    by (simp add: associative del: invertible_left_inverse invertible_right_inverse)
  also have "â€¦ = ğŸ­" by simp
  finally have inv1: "(u1 â‹… u2) â‹… (inverse u2 â‹… inverse u1) = ğŸ­" by simp  â€• â€¹ll 16--18â€º
  have "(inverse u2 â‹… inverse u1) â‹… (u1 â‹… u2) = (inverse u2 â‹… (inverse u1 â‹… u1)) â‹… u2"
    by (simp add: associative del: invertible_left_inverse invertible_right_inverse)
  also have "â€¦ = ğŸ­" by simp
  finally have inv2: "(inverse u2 â‹… inverse u1) â‹… (u1 â‹… u2) = ğŸ­" by simp  â€• â€¹l 9, ``and similarly''â€º
  show "u1 â‹… u2 âˆˆ Units" using inv1 inv2 invertibleI mem_UnitsI by auto
qed (auto simp: Units_def)
```

Composition of inverses is an inverse of compositions

```
text â€¹p 31, l 22â€º
lemma inverse_composition_commute:
  assumes [simp]: "invertible x" "invertible y" "x âˆˆ M" "y âˆˆ M"
  shows "inverse (x â‹… y) = inverse y â‹… inverse x"
proof -
  have "inverse (x â‹… y) â‹… (x â‹… y) = (inverse y â‹… inverse x) â‹… (x â‹… y)"
  by (simp add: invertible_left_inverse2 associative)
  then show ?thesis by (simp del: invertible_left_inverse)
qed
```

#### Transformations

Let's consider the example monoid of transformations.
A function `Î±` from `S` to `S` has an inverse *Î±<sup>-1</sup>* if *Î±(Î±<sup>-1</sup>(s))=s*
and *Î±<sup>-1</sup>(Î±(s))=s* holds for all `s âˆˆ S`. Such `Î±<sup>-1</sup>` can exist only if
`Î±` is a bijection (\@ref(inj-sur-bij)).

```
context transformations begin

text â€¹p 31, ll 25--26â€º
theorem invertible_is_bijective:
  assumes dom: "Î± âˆˆ S â†’â‡©E S"
  shows "invertible Î± âŸ· bij_betw Î± S S"
proof -
  from dom interpret map Î± S S by unfold_locales
  show ?thesis by (auto simp add: bij_betw_iff_has_inverse invertible_def)
qed
```

Therefore, the set of bijective functions forms a group

```
text â€¹p 31, ll 26--27â€º
theorem Units_bijective:
  "Units = {Î± âˆˆ S â†’â‡©E S. bij_betw Î± S S}"
  unfolding Units_def by (auto simp add: invertible_is_bijective)
```

This group has very special properties and occurs in many places. Mathematicians gave it
a special name and call this set the *symmetric group*. When the domain `S` is finite and has
`n` elements then the standard notation for this group is ***S**<sub>n</sub>* (The bold **S** stands for "symmetric". The fact that domain is denoted by `S` is purely coincidental). 


```
text â€¹p 31, ll 28--29â€º
abbreviation "Sym â‰¡ Units"

text â€¹p 31, ll 26--28â€º
sublocale symmetric: group "Sym" "compose S" "identity S"
  by (fact group_of_Units)

end (* transformations *)
```

### Homomorphisms




### Equivalence classes


```
text â€¹p 11, ll 6--11â€º
locale equivalence =
  fixes S and E
  assumes closed [intro, simp]: "E âŠ† S Ã— S"
    and reflexive [intro, simp]: "a âˆˆ S âŸ¹ (a, a) âˆˆ E"
    and symmetric [sym]: "(a, b) âˆˆ E âŸ¹ (b, a) âˆˆ E"
    and transitive [trans]: "âŸ¦ (a, b) âˆˆ E; (b, c) âˆˆ E âŸ§ âŸ¹ (a, c) âˆˆ E"
begin

text â€¹p 11, ll 6--11â€º
lemma left_closed [intro]: (* inefficient as a simp rule *)
  "(a, b) âˆˆ E âŸ¹ a âˆˆ S"
  using closed by blast
  
text â€¹p 11, ll 6--11â€º
lemma right_closed [intro]: (* inefficient as a simp rule *)
  "(a, b) âˆˆ E âŸ¹ b âˆˆ S"
  using closed by blast
  
end
```

